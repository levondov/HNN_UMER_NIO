function varargout = misalign(varargin)
% THERING = MISALIGN(misaligndata) will go through THERING and
% generage the misalignment based on the information provided in
% misaligndata which is generated by setmisalignment.
%
% See also MISALIGNDATA

% misalign.individual(n).name
%                       .onesigma.x
%                                .y
%                                .z
%                                .thetax
%                                .thetay
%                                .thetaz
%                       .cutoff
%                       .index             (optional)
% misalign.girder(n).name
%                   .firstelement
%                   .lastelement
%                   .onesigma.x
%                            .y
%                            .z
%                            .thetax
%                            .thetay
%                            .thetaz
%                   .cutoff
%                   .index             (optional)
% misalign.startelementindex
% misalign.time
% misalign.title
% midalign.data.element(n).name (?)
%                         .ATindex
%                         .x
%                         .y
%                         .z
%                         .thetax
%                         .thetay
%                         .thetaz
% 
% Assumes THERING is the definition of the lattice that the misalignment
% will be affecting.

global THERING

% Parse input parameters
for i=1:nargin
    if isstruct(varargin{i})
        misaligndata = varargin{i};
    else
        disp(['Parameter number ' num2str(i) ' not recognised.']);
    end
end

misaligndata.individual(1).name = 'halfqd';
misaligndata.individual(1).sigma.x = 1e-2;
misaligndata.individual(1).sigma.y = 1e-2;
misaligndata.individual(1).sigma.z = 1e-2;
misaligndata.individual(1).sigma.thetax = 1e-3;
misaligndata.individual(1).sigma.thetay = 1e-3;
misaligndata.individual(1).sigma.thetaz = 1e-3;
misaligndata.individual(1).cutoff = 2;
misaligndata.individual(2).name = 'halfqf';
misaligndata.individual(2).sigma.x = 1e-2;
misaligndata.individual(2).sigma.y = 1e-2;
misaligndata.individual(2).sigma.z = 1e-2;
misaligndata.individual(2).sigma.thetax = 1e-3;
misaligndata.individual(2).sigma.thetay = 1e-3;
misaligndata.individual(2).sigma.thetaz = 1e-3;
misaligndata.individual(2).cutoff = 2;

% Apply individual magnet misalignment
for i=1:length(misaligndata.individual)
    indices = findcells(THERING,'FamName',misaligndata.individual(i).name);
    if ~isempty(indices)
        xshift = generaterandom(misaligndata.individual(i).sigma.x,length(indices),misaligndata.individual(i).cutoff);
        yshift = generaterandom(misaligndata.individual(i).sigma.y,length(indices),misaligndata.individual(i).cutoff);
        addshift(indices,xshift,yshift);

        % This is not used yet
        %     zshift = generaterandom(misaligndata.individual(i).sigma.z,misaligndata.individual(i).cutoff);

        xrot = generaterandom(misaligndata.individual(i).sigma.thetax,length(indices),misaligndata.individual(i).cutoff);
        yrot = generaterandom(misaligndata.individual(i).sigma.thetay,length(indices),misaligndata.individual(i).cutoff);
        srot = generaterandom(misaligndata.individual(i).sigma.thetaz,length(indices),misaligndata.individual(i).cutoff);
        addxrot(indices,xrot);
        addyrot(indices,yrot);
        addsrot(indices,srot);
    end
end

% To store a local copy of the RING elements without the drift elements.
% Will aso scan through and determine which group of elements belong to
% which girder and retrieve the relavent indices. LOCALRINGMAP is a
% mapping from LOCALRING to the RING elements.
localring = {};
localringmap = [];
ind = 0;
girdernumber = 0;
for i=1:length(ring)
    if ~isempty(regexp(ring{i}.PassMethod,'MPole')) | ...
            ~isempty(regexp(ring{i}.PassMethod,'Linear'))

        ind = ind + 1;
        localring{ind} = ring{i};
        localringmap(ind) = i;
    end

end


function randnum = generaterandom(sigma,num,cutoff)

randnum = sigma*randn(1,num);

ind = find(abs(randnum) > cutoff*sigma);
while ~isempty(ind)
    randnum(ind) = sigma*randn(1,length(ind));
    ind = find(abs(randnum) > cutoff*sigma);
end

randnum(find(randnum > cutoff*sigma))  =  cutoff*sigma;
randnum(find(randnum < -cutoff*sigma)) = -cutoff*sigma;